import json
import os
from dataclasses import dataclass
from pathlib import Path
from typing import Callable

import numpy as np
from Bio import AlignIO, SeqIO, Align

from slim_conservation_scoring.seqtools import general_utils as tools
import slim_conservation_scoring.conservation_scores.tools.basic_plotting as basic_plotting
import matplotlib.pyplot as plt
import matplotlib.axes
import matplotlib.figure
import copy


class ConserGene:
    """
    This class is for reading the json files generated by the conservation pipeline.
    """

    def __init__(self, json_filepath, filepath_converter: Callable | None = None):
        if filepath_converter is not None:
            json_filepath = filepath_converter(json_filepath)
        self.json_filepath = Path(json_filepath)
        with open(self.json_filepath, "r") as f:
            self.info_dict = json.load(f)

        self.reference_index = self.info_dict["reference_index"]
        if "critical_error" in self.info_dict:
            self.critical_error = self.info_dict["critical_error"]
            return
        self.query_gene_id = self.info_dict["query_gene_id"]
        self.hit_sequence = self.info_dict["hit_sequence"]
        self.query_sequence = self.info_dict["query_sequence"]
        self.hit_start_position = self.info_dict["hit_start_position"]
        self.hit_end_position = self.info_dict["hit_end_position"]
        self.hit_in_idr = self.info_dict["hit_in_idr"]
        self.idr_start = self.info_dict["idr_start"]
        self.idr_end = self.info_dict["idr_end"]
        if "analysis_folder" in self.info_dict:
            self.analysis_folder = self.info_dict["analysis_folder"]
        self.levels_passing_filters = self.info_dict["levels_passing_filters"]
        # self.level_objects: dict[str, ConserLevel] | None = None
        # self.aln_score_objects: dict[str, LevelAlnScore] | None = None
        self.hit_st_in_idr = self.hit_start_position - self.idr_start
        self.hit_end_in_idr = self.hit_end_position - self.idr_start
        self.query_idr_sequence = self.query_sequence[self.idr_start : self.idr_end + 1]

    def get_level_obj(self, level, filepath_converter: None | Callable = None):
        return ConserLevel(
            self.info_dict["orthogroups"][level],
            query_gene_id=self.query_gene_id,
            filepath_converter=filepath_converter,
        )

    def load_levels(self, filepath_converter: None | Callable = None):
        self.level_objects = {}
        for level in self.levels_passing_filters:
            self.level_objects[level] = self.get_level_obj(
                level, filepath_converter=filepath_converter
            )

    def get_aln_score_obj(
        self,
        level,
        score_key,
        bg_region=None,
        num_bg_scores_cutoff=20,
        filepath_converter: None | Callable = None,
    ):
        level_obj = self.get_level_obj(level, filepath_converter=filepath_converter)
        return LevelAlnScore.from_conser_level(
            level_obj,
            score_key,
            bg_region=bg_region,
            num_bg_scores_cutoff=num_bg_scores_cutoff,
            query_gene_id=self.query_gene_id,
            filepath_converter=filepath_converter,
        )

    def load_aln_scores(
        self,
        score_key,
        bg_region=None,
        num_bg_scores_cutoff=20,
        filepath_converter: None | Callable = None,
    ):
        self.aln_score_objects = {}
        self.load_levels(filepath_converter=filepath_converter)
        for level, level_obj in self.level_objects.items():
            self.aln_score_objects[level] = self.get_aln_score_obj(
                level,
                score_key,
                bg_region=bg_region,
                num_bg_scores_cutoff=num_bg_scores_cutoff,
                filepath_converter=filepath_converter,
            )

    def _overwrite_json(self):
        with open(self.json_filepath, "w") as f:
            json.dump(self.info_dict, f, indent=4)

    def add_item_to_json(self, key, value, save_json=True):
        self.info_dict[key] = value
        if save_json:
            self._overwrite_json()

    def add_item_to_lvl_orthogroup(self, key, value, level, save_json=True):
        self.info_dict["orthogroups"][level][key] = value
        if save_json:
            self._overwrite_json()


class ConserLevel:
    def __init__(
        self,
        lvl_dict,
        query_gene_id=None,
        filepath_converter: None | Callable = None,
    ):
        self.info_dict = lvl_dict
        if filepath_converter is not None:
            self.alignment_file = filepath_converter(lvl_dict["alignment_file"])
        else:
            self.alignment_file = lvl_dict["alignment_file"]
        self.hit_aln_start = lvl_dict["hit_aln_start"]
        self.hit_aln_end = lvl_dict["hit_aln_end"]
        self.idr_aln_start = lvl_dict["idr_aln_start"]
        self.idr_aln_end = lvl_dict["idr_aln_end"]
        self.query_aln_sequence = lvl_dict["query_aln_sequence"]
        self.hit_aln_sequence = lvl_dict["hit_aln_sequence"]
        self.hit_nongap_inds = tools.get_non_gap_indexes(self.hit_aln_sequence)
        self.hit_sequence = self.hit_aln_sequence.replace("-", "")
        self.num_clustered_ldos = lvl_dict["num_clustered_ldos"]
        self.conservation_scores = lvl_dict["conservation_scores"]
        with open(self.alignment_file, "r") as f:
            self.aln = AlignIO.read(f, "fasta")
        if query_gene_id is not None:
            self.query_gene_id = query_gene_id
            self.aln = self.reorder_aln(query_gene_id)

    def get_idr_dict(self):
        idr_aln = self.aln[:, self.idr_aln_start : self.idr_aln_end + 1]
        idrs = tools.strip_dashes_from_sequences(list(idr_aln))  # type: ignore
        idrs = {i.id: str(i.seq) for i in idrs}
        return idrs

    def reorder_aln(self, query_gene_id) -> Align.MultipleSeqAlignment:
        """order the alignment so that the sequence with the query gene id is first"""
        aln_dict = {i.id: i for i in self.aln}
        query_seq = aln_dict.pop(query_gene_id)
        aln_list = [query_seq] + list(aln_dict.values())
        return Align.MultipleSeqAlignment(aln_list)


class LevelAlnScore(ConserLevel):

    def __init__(
        self,
        lvl_dict,
        score_key,
        bg_region=None,
        num_bg_scores_cutoff=20,
        query_gene_id=None,
        filepath_converter: None | Callable = None,
    ):
        super().__init__(
            lvl_dict, query_gene_id=query_gene_id, filepath_converter=filepath_converter
        )
        # self.scores = None
        # self.score_mask = None
        # self.gap_mask = None
        # self.z_scores: list | None = None
        # self.bg_scores: list | None = None
        self.z_score_failure: str | None = None
        # self.hit_aln_scores: list | None = None
        # self.hit_scores: list | None = None
        # self.hit_aln_z_scores: list | None = None
        # self.hit_z_scores: list | None = None
        if filepath_converter is not None:
            self.score_file = filepath_converter(
                self.conservation_scores[score_key]["file"]
            )
        else:
            self.score_file = self.conservation_scores[score_key]["file"]
        self.function_name = self.conservation_scores[score_key]["function_name"]
        self.function_params = self.conservation_scores[score_key]["function_params"]
        self.calculate_z_scores_bg_region(bg_region, num_bg_scores_cutoff)
        self.calculate_hit_scores()
        if self.z_score_failure is None:
            self.calculate_hit_zscores()
            self.bg_std = np.std(self.bg_scores)
            self.bg_mean = np.mean(self.bg_scores)

    @classmethod
    def from_conser_level(
        cls,
        conser_level: ConserLevel,
        score_key,
        bg_region=None,
        num_bg_scores_cutoff=20,
        query_gene_id=None,
        filepath_converter: None | Callable = None,
    ):
        return cls(
            conser_level.info_dict,
            score_key,
            bg_region,
            num_bg_scores_cutoff,
            query_gene_id=query_gene_id,
            filepath_converter=filepath_converter,
        )

    def load_scores(self):
        with open(self.score_file, "r") as f:
            score_dict = json.load(f)
        self.scores = score_dict["scores"]
        self.score_mask = score_dict["score_mask"]
        self.gap_mask = score_dict["gap_mask"]

    def calculate_z_scores_bg_region(self, bg_region=None, num_bg_scores_cutoff=20):
        self.load_scores()
        if bg_region is None:
            bg_region = [self.idr_aln_start, self.idr_aln_end + 1]
        try:
            z_score_dict = tools.calculate_z_score_bg_region(
                self.scores,
                self.score_mask,
                bg_region,
                num_bg_scores_cutoff=num_bg_scores_cutoff,
            )
        except ValueError as ve:
            self.z_score_failure = str(ve)
            return
        self.z_scores = z_score_dict["z_scores"]
        self.bg_scores = z_score_dict["bg_scores"]

    def calculate_hit_scores(self):
        hit_slice = slice(self.hit_aln_start, self.hit_aln_end + 1)
        self.hit_aln_scores = self.scores[hit_slice]
        nongap_inds = tools.get_non_gap_indexes(self.hit_aln_sequence)
        self.hit_scores = list(np.array(self.hit_aln_scores)[nongap_inds])

    def calculate_hit_zscores(self):
        hit_slice = slice(self.hit_aln_start, self.hit_aln_end + 1)
        self.hit_aln_z_scores = self.z_scores[hit_slice]
        nongap_inds = tools.get_non_gap_indexes(self.hit_aln_sequence)
        self.hit_z_scores = list(np.array(self.hit_aln_z_scores)[nongap_inds])

    def _create_axes_if_none(
        self, ax: matplotlib.axes.Axes | None = None
    ) -> matplotlib.axes.Axes:
        if ax is None:
            fig, ax = plt.subplots(figsize=(4, 4))
        return ax  # type: ignore

    def plot_background_distribution(
        self,
        ax: matplotlib.axes.Axes | None = None,
        bins=20,
    ):
        """plot the background conservation scores as a histogram

        Parameters
        ----------
        ax : matplotlib.axes.Axes | None, optional
            if provided, the histogram will be plotted on the provided axes. If
            None, a new axes will be created. by default None
        bins : int, other, optional
            passed to the `plt.hist` matplotlib function, by default 20

        Returns
        -------
        matplotlib.axes.Axes
            matplotlib axes with the background conservation score histogram
        """
        ax = self._create_axes_if_none(ax)
        ax.hist(self.bg_scores, bins=bins, edgecolor="none")
        # ax.set_title("Background")
        ax.set_xlabel("Conservation score")
        ax.set_ylabel("Count")
        ax.axvline(self.bg_mean, color="red", linestyle=":", label="Mean", linewidth=3)
        ax.axvline(
            self.bg_mean + self.bg_std, color="black", label="1 std", linewidth=2
        )
        ax.axvline(
            self.bg_mean - self.bg_std, color="black", label="-1 std", linewidth=2
        )
        ax.legend(["Mean", "+/- 1 std"], prop={"size": 12})
        ax.set_xlim(0, 1)
        return ax

    def _check_z_scores(self):
        if self.z_score_failure is not None:
            raise ValueError(
                f"No z-scores calculated for {self.score_file}: {self.z_score_failure}"
            )

    def plot_score_barplot(
        self,
        z_score: bool = True,
        strip_gaps: bool = True,
        ax: matplotlib.axes.Axes | None = None,
    ):
        """_summary_

        Parameters
        ----------
        z_score : bool, optional
            whether or not to plot z_scores, by default True (z_score). If False,
            the raw scores will be plotted.
        strip_gaps : bool, optional
            whether or not to remove gap positions from the hit sequence, by default True
        ax : matplotlib.axes.Axes | None, optional
            if provided, the barplot will be plotted on the provided axes. If
            None, a new axes will be created. by default None

        Returns
        -------
        matplotlib.axes.Axes
            matplotlib axes with the plot
        """
        ax = self._create_axes_if_none(ax)
        if z_score:
            self._check_z_scores()
        if z_score and strip_gaps:
            scores = copy.deepcopy(self.hit_z_scores)
            seq = copy.deepcopy(self.hit_sequence)
        elif not z_score and strip_gaps:
            scores = copy.deepcopy(self.hit_scores)
            seq = copy.deepcopy(self.hit_sequence)
        elif z_score and not strip_gaps:
            scores = copy.deepcopy(self.hit_aln_z_scores)
            seq = copy.deepcopy(self.hit_aln_sequence)
        elif not z_score and not strip_gaps:
            scores = copy.deepcopy(self.hit_aln_scores)
            seq = copy.deepcopy(self.hit_aln_sequence)
        ax = basic_plotting.plot_score_bar_plot(
            ax,
            list(scores),
            seq,
        )
        return ax

    @staticmethod
    def strip_gaps_from_slice(alignment_slice, query_aln_seq_str):
        """strip gaps from alignment slice"""
        new_sequences = [""] * (len(alignment_slice))
        non_gap_indices = tools.get_non_gap_indexes(query_aln_seq_str)
        for c in non_gap_indices:
            for j in range(len(new_sequences)):
                new_sequences[j] += alignment_slice[j, c]
        return new_sequences

    def plot_sequence_logo(
        self,
        strip_gaps: bool = True,
        ax: matplotlib.axes.Axes | None = None,
    ):
        """plot the query k-mer "pseudo-MSA" as a sequence logo where the residue
        height is proportional to the number of homologs with that residue at
        that position. The query k-mer is included in the "pseudo-MSA"

        Parameters
        ----------
        strip_gaps : bool, optional
            whether or not to remove gap positions (in the query sequence) from
            the alignment, by default True. note - Gaps can still be present in
            the orthologs.
        ax : matplotlib.axes.Axes | None, optional
            if provided, the sequence logo will be plotted on the provided axes.
            If None, a new axes will be created. by default None

        Returns
        -------
        matplotlib.axes.Axes
            matplotlib axes with the plot
        """
        ax = self._create_axes_if_none(ax)
        aln_slice = self.aln[:, self.hit_aln_start : self.hit_aln_end + 1]
        if strip_gaps:
            aln_strs = self.strip_gaps_from_slice(aln_slice, self.hit_aln_sequence)
            seq = self.hit_sequence
        else:
            aln_strs = [str(i.seq) for i in aln_slice]
            seq = self.hit_aln_sequence
        ax = basic_plotting.plot_logo(ax, aln_strs, seq)
        return ax

    def plot_conservation_mosaic(
        self,
        z_score: bool = True,
        strip_gaps: bool = True,
        figsize: tuple[int, int] = (15, 5),
    ) -> tuple[matplotlib.figure.Figure, dict[str, matplotlib.axes.Axes]]:
        """makes a mosaic plot (with multiple subplots) of the conservation
        scores, sequence logos, and background scores for the MSA conservation results.

        Parameters
        ----------
        z_score : bool, optional
            whether or not to plot z_scores, by default True (z_score). If False,
            the raw scores will be plotted.
        strip_gaps : bool, optional
            whether or not to remove gap positions (in the query sequence) from
            the hit sequence and alignment, by default True. note - Gaps can
            still be present in the orthologs which will be reflected in the
            sequence logo.
        figsize : tuple[int, int], optional
            the size of the figure, by default (15, 5)

        Returns
        -------
        tuple[matplotlib.figure.Figure, dict[str, matplotlib.axes.Axes]]
            the figure and axes dictionary for the mosaic plot.
        """
        fig, axd = basic_plotting.build_mosaic_z_score_plot(figsize=figsize)
        axd["background"] = self.plot_background_distribution(axd["background"])
        axd["scores"] = self.plot_score_barplot(
            z_score=z_score, strip_gaps=strip_gaps, ax=axd["scores"]
        )
        axd["logo"] = self.plot_sequence_logo(strip_gaps=strip_gaps, ax=axd["logo"])
        return fig, axd
