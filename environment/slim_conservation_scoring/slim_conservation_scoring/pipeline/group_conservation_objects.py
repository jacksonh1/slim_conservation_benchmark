import json
import os
from dataclasses import dataclass
from pathlib import Path
from typing import Callable

import numpy as np
from Bio import AlignIO, SeqIO, Align

from slim_conservation_scoring.seqtools import general_utils as tools


class ConserGene:
    """
    This class is for reading the json files generated by the conservation pipeline.
    """

    def __init__(self, json_filepath, filepath_converter: Callable | None = None):
        if filepath_converter is not None:
            json_filepath = filepath_converter(json_filepath)
        self.json_filepath = Path(json_filepath)
        with open(self.json_filepath, "r") as f:
            self.info_dict = json.load(f)

        self.reference_index = self.info_dict["reference_index"]
        if "critical_error" in self.info_dict:
            self.critical_error = self.info_dict["critical_error"]
            return
        self.query_gene_id = self.info_dict["query_gene_id"]
        self.hit_sequence = self.info_dict["hit_sequence"]
        self.query_sequence = self.info_dict["query_sequence"]
        self.hit_start_position = self.info_dict["hit_start_position"]
        self.hit_end_position = self.info_dict["hit_end_position"]
        self.hit_in_idr = self.info_dict["hit_in_idr"]
        self.idr_start = self.info_dict["idr_start"]
        self.idr_end = self.info_dict["idr_end"]
        if "analysis_folder" in self.info_dict:
            self.analysis_folder = self.info_dict["analysis_folder"]
        self.levels_passing_filters = self.info_dict["levels_passing_filters"]
        # self.level_objects: dict[str, ConserLevel] | None = None
        # self.aln_score_objects: dict[str, LevelAlnScore] | None = None
        self.hit_st_in_idr = self.hit_start_position - self.idr_start
        self.hit_end_in_idr = self.hit_end_position - self.idr_start
        self.query_idr_sequence = self.query_sequence[self.idr_start : self.idr_end + 1]

    def get_level_obj(self, level, filepath_converter: None | Callable = None):
        return ConserLevel(
            self.info_dict["orthogroups"][level],
            query_gene_id=self.query_gene_id,
            filepath_converter=filepath_converter,
        )

    def load_levels(self, filepath_converter: None | Callable = None):
        self.level_objects = {}
        for level in self.levels_passing_filters:
            self.level_objects[level] = self.get_level_obj(
                level, filepath_converter=filepath_converter
            )

    def get_aln_score_obj(
        self,
        level,
        score_key,
        bg_region=None,
        num_bg_scores_cutoff=20,
        filepath_converter: None | Callable = None,
    ):
        level_obj = self.get_level_obj(level, filepath_converter=filepath_converter)
        return LevelAlnScore.from_conser_level(
            level_obj,
            score_key,
            bg_region=bg_region,
            num_bg_scores_cutoff=num_bg_scores_cutoff,
            query_gene_id=self.query_gene_id,
            filepath_converter=filepath_converter,
        )

    def load_aln_scores(
        self,
        score_key,
        bg_region=None,
        num_bg_scores_cutoff=20,
        filepath_converter: None | Callable = None,
    ):
        self.aln_score_objects = {}
        self.load_levels(filepath_converter=filepath_converter)
        for level, level_obj in self.level_objects.items():
            self.aln_score_objects[level] = self.get_aln_score_obj(
                level,
                score_key,
                bg_region=bg_region,
                num_bg_scores_cutoff=num_bg_scores_cutoff,
                filepath_converter=filepath_converter,
            )

    def _overwrite_json(self):
        with open(self.json_filepath, "w") as f:
            json.dump(self.info_dict, f, indent=4)

    def add_item_to_json(self, key, value, save_json=True):
        self.info_dict[key] = value
        if save_json:
            self._overwrite_json()

    def add_item_to_lvl_orthogroup(self, key, value, level, save_json=True):
        self.info_dict["orthogroups"][level][key] = value
        if save_json:
            self._overwrite_json()


class ConserLevel:
    def __init__(
        self,
        lvl_dict,
        query_gene_id=None,
        filepath_converter: None | Callable = None,
    ):
        self.info_dict = lvl_dict
        if filepath_converter is not None:
            self.alignment_file = filepath_converter(lvl_dict["alignment_file"])
        else:
            self.alignment_file = lvl_dict["alignment_file"]
        self.hit_aln_start = lvl_dict["hit_aln_start"]
        self.hit_aln_end = lvl_dict["hit_aln_end"]
        self.idr_aln_start = lvl_dict["idr_aln_start"]
        self.idr_aln_end = lvl_dict["idr_aln_end"]
        self.query_aln_sequence = lvl_dict["query_aln_sequence"]
        self.hit_aln_sequence = lvl_dict["hit_aln_sequence"]
        self.num_clustered_ldos = lvl_dict["num_clustered_ldos"]
        self.conservation_scores = lvl_dict["conservation_scores"]
        with open(self.alignment_file, "r") as f:
            self.aln = AlignIO.read(f, "fasta")
        if query_gene_id is not None:
            self.query_gene_id = query_gene_id
            self.aln = self.reorder_aln(query_gene_id)

    def get_idr_dict(self):
        idr_aln = self.aln[:, self.idr_aln_start : self.idr_aln_end + 1]
        idrs = tools.strip_dashes_from_sequences(list(idr_aln))  # type: ignore
        idrs = {i.id: str(i.seq) for i in idrs}
        return idrs

    def reorder_aln(self, query_gene_id):
        """order the alignment so that the sequence with the query gene id is first"""
        aln_dict = {i.id: i for i in self.aln}
        query_seq = aln_dict.pop(query_gene_id)
        aln_list = [query_seq] + list(aln_dict.values())
        return Align.MultipleSeqAlignment(aln_list)


class LevelAlnScore(ConserLevel):

    def __init__(
        self,
        lvl_dict,
        score_key,
        bg_region=None,
        num_bg_scores_cutoff=20,
        query_gene_id=None,
        filepath_converter: None | Callable = None,
    ):
        super().__init__(
            lvl_dict, query_gene_id=query_gene_id, filepath_converter=filepath_converter
        )
        # self.scores = None
        # self.score_mask = None
        # self.gap_mask = None
        # self.z_scores: list | None = None
        # self.bg_scores: list | None = None
        self.z_score_failure: str | None = None
        # self.hit_aln_scores: list | None = None
        # self.hit_scores: list | None = None
        # self.hit_aln_z_scores: list | None = None
        # self.hit_z_scores: list | None = None
        if filepath_converter is not None:
            self.score_file = filepath_converter(
                self.conservation_scores[score_key]["file"]
            )
        else:
            self.score_file = self.conservation_scores[score_key]["file"]
        self.function_name = self.conservation_scores[score_key]["function_name"]
        self.function_params = self.conservation_scores[score_key]["function_params"]
        self.calculate_z_scores_bg_region(bg_region, num_bg_scores_cutoff)
        self.calculate_hit_scores()
        if self.z_score_failure is None:
            self.calculate_hit_zscores()

    @classmethod
    def from_conser_level(
        cls,
        conser_level: ConserLevel,
        score_key,
        bg_region=None,
        num_bg_scores_cutoff=20,
        query_gene_id=None,
        filepath_converter: None | Callable = None,
    ):
        return cls(
            conser_level.info_dict,
            score_key,
            bg_region,
            num_bg_scores_cutoff,
            query_gene_id=query_gene_id,
            filepath_converter=filepath_converter,
        )

    def load_scores(self):
        with open(self.score_file, "r") as f:
            score_dict = json.load(f)
        self.scores = score_dict["scores"]
        self.score_mask = score_dict["score_mask"]
        self.gap_mask = score_dict["gap_mask"]

    def calculate_z_scores_bg_region(self, bg_region=None, num_bg_scores_cutoff=20):
        self.load_scores()
        if bg_region is None:
            bg_region = [self.idr_aln_start, self.idr_aln_end + 1]
        try:
            z_score_dict = tools.calculate_z_score_bg_region(
                self.scores,
                self.score_mask,
                bg_region,
                num_bg_scores_cutoff=num_bg_scores_cutoff,
            )
        except ValueError as ve:
            self.z_score_failure = str(ve)
            return
        self.z_scores = z_score_dict["z_scores"]
        self.bg_scores = z_score_dict["bg_scores"]

    def calculate_hit_scores(self):
        hit_slice = slice(self.hit_aln_start, self.hit_aln_end + 1)
        self.hit_aln_scores = self.scores[hit_slice]
        nongap_inds = tools.get_non_gap_indexes(self.hit_aln_sequence)
        self.hit_scores = list(np.array(self.hit_aln_scores)[nongap_inds])

    def calculate_hit_zscores(self):
        hit_slice = slice(self.hit_aln_start, self.hit_aln_end + 1)
        self.hit_aln_z_scores = self.z_scores[hit_slice]
        nongap_inds = tools.get_non_gap_indexes(self.hit_aln_sequence)
        self.hit_z_scores = list(np.array(self.hit_aln_z_scores)[nongap_inds])
